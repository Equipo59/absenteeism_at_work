name: Deploy to AWS EC2

# Deployment solo ocurre cuando se hace push a la rama 'web'
# master/main = desarrollo (sin deploy autom√°tico)
# web = producci√≥n (con deploy autom√°tico)
#
# Usa AWS Systems Manager (SSM) para deployment sin necesidad de SSH keys
# Requiere configurar GitHub Secrets:
# - AWS_ACCESS_KEY_ID
# - AWS_SECRET_ACCESS_KEY
# - AWS_ACCOUNT_ID

on:
  push:
    branches:
      - web
  workflow_dispatch:  # Allows manual trigger from any branch

env:
  AWS_REGION: us-east-1
  EC2_INSTANCE_TYPE: t3.micro
  DOCKER_IMAGE_NAME: absenteeism-api

jobs:
  deploy:
    name: Build, Train, and Deploy
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install --no-cache-dir -r requirements.txt
          pip install --no-cache-dir -r requirements-api.txt || pip install --no-cache-dir fastapi uvicorn pydantic
          pip install --no-cache-dir boto3 awscli

      - name: Preprocess data
        run: |
          python -m absenteeism_at_work.preprocess_data

      - name: Train model
        run: |
          python -m absenteeism_at_work.modeling.train

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.6.0"

      - name: Setup infrastructure (Terraform)
        working-directory: infrastructure/terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TF_VAR_aws_region: ${{ env.AWS_REGION }}
          TF_VAR_ec2_instance_type: ${{ env.EC2_INSTANCE_TYPE }}
          TF_VAR_use_existing_vpc: "true"
        run: |
          terraform init -upgrade
          # Try to import IAM resources if they already exist but not in state
          if ! terraform state list 2>/dev/null | grep -q "aws_iam_role.ec2_ssm_role"; then
            terraform import aws_iam_role.ec2_ssm_role absenteeism-ec2-ssm-role || echo "IAM role doesn't exist yet"
          fi
          if ! terraform state list 2>/dev/null | grep -q "aws_iam_role_policy.s3_deployment_access"; then
            terraform import aws_iam_role_policy.s3_deployment_access "absenteeism-ec2-ssm-role:absenteeism-s3-deployment-access" || echo "IAM role policy doesn't exist yet"
          fi
          if ! terraform state list 2>/dev/null | grep -q "aws_iam_instance_profile.ec2_ssm_profile"; then
            terraform import aws_iam_instance_profile.ec2_ssm_profile absenteeism-ec2-ssm-profile || echo "Instance profile doesn't exist yet"
          fi
          terraform plan -out=tfplan
          terraform apply -auto-approve

      - name: Clean up Docker system
        run: |
          docker system prune -af --volumes || true
          docker builder prune -af || true

      - name: Build Docker image
        id: build-docker
        run: |
          docker build -t ${{ env.DOCKER_IMAGE_NAME }}:latest .
          docker tag ${{ env.DOCKER_IMAGE_NAME }}:latest ${{ env.DOCKER_IMAGE_NAME }}:${{ github.sha }}
          echo "‚úÖ Docker image built successfully"
          docker images ${{ env.DOCKER_IMAGE_NAME }} --format "{{.Repository}}:{{.Tag}}" || echo "‚ö†Ô∏è Image listing failed"

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
        continue-on-error: true

      - name: Create ECR repository (if not exists)
        continue-on-error: true
        run: |
          aws ecr create-repository --repository-name ${{ env.DOCKER_IMAGE_NAME }} --region ${{ env.AWS_REGION }} || true

      - name: Push Docker image to ECR
        if: steps.login-ecr.outcome == 'success' && steps.build-docker.outcome == 'success'
        continue-on-error: true
        run: |
          # Verify image exists before tagging
          if ! docker images ${{ env.DOCKER_IMAGE_NAME }}:latest --format "{{.Repository}}:{{.Tag}}" | grep -q "${{ env.DOCKER_IMAGE_NAME }}:latest"; then
            echo "‚ùå Docker image ${{ env.DOCKER_IMAGE_NAME }}:latest not found"
            echo "Available images:"
            docker images | head -10
            exit 1
          fi
          docker tag ${{ env.DOCKER_IMAGE_NAME }}:latest ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.DOCKER_IMAGE_NAME }}:latest
          docker push ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.DOCKER_IMAGE_NAME }}:latest

      - name: Clean up Docker after push
        if: always()
        run: |
          docker system prune -af || true

      - name: Get EC2 instance info
        id: get-ec2-info
        working-directory: infrastructure/terraform
        run: |
          INSTANCE_IP=$(terraform output -raw instance_ip 2>/dev/null || aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=absenteeism-api" "Name=instance-state-name,Values=running" \
            --query 'Reservations[0].Instances[0].PublicIpAddress' \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          INSTANCE_ID=$(terraform output -raw instance_id 2>/dev/null || aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=absenteeism-api" "Name=instance-state-name,Values=running" \
            --query 'Reservations[0].Instances[0].InstanceId' \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          echo "instance_ip=$INSTANCE_IP" >> $GITHUB_OUTPUT
          echo "instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT
          echo "EC2 IP: $INSTANCE_IP"
          echo "EC2 Instance ID: $INSTANCE_ID"
          
          # Wait for SSM agent to be ready
          echo "Waiting for SSM agent to register..."
          sleep 30

      - name: Create S3 bucket for deployment
        id: create-bucket
        run: |
          BUCKET_NAME="absenteeism-deployment-${{ github.run_number }}"
          echo "bucket_name=$BUCKET_NAME" >> $GITHUB_OUTPUT
          
          # Create bucket or use existing
          aws s3api create-bucket \
            --bucket $BUCKET_NAME \
            --region ${{ env.AWS_REGION }} \
            || echo "Bucket may already exist"
          
          # Tag with lifecycle policy
          aws s3api put-bucket-tagging \
            --bucket $BUCKET_NAME \
            --tagging "TagSet=[{Key=Project,Value=absenteeism},{Key=AutoDelete,Value=true}]"

      - name: Package and upload files to S3
        run: |
          echo "Packaging application..."
          # Use git archive to avoid file change issues
          git archive --format=tar.gz \
            --output=deploy.tar.gz \
            --prefix=./ \
            HEAD
          
          echo "Checking if tar file was created..."
          if [ ! -f deploy.tar.gz ]; then
            echo "‚ùå Failed to create deploy.tar.gz"
            exit 1
          fi
          
          echo "Uploading to S3..."
          aws s3 cp deploy.tar.gz s3://${{ steps.create-bucket.outputs.bucket_name }}/deploy.tar.gz

      - name: Deploy on EC2 via SSM
        run: |
          echo "Deploying application on EC2 via AWS Systems Manager..."
          
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "${{ steps.get-ec2-info.outputs.instance_id }}" \
            --document-name "AWS-RunShellScript" \
            --parameters "commands=[
              'cd /home/ubuntu',
              'mkdir -p absenteeism_at_work',
              'cd absenteeism_at_work',
              'aws s3 cp s3://${{ steps.create-bucket.outputs.bucket_name }}/deploy.tar.gz .',
              'tar -xzf deploy.tar.gz || true',
              'chmod +x scripts/deploy.sh',
              'export DEPLOYMENT_MODE=ci',
              './scripts/deploy.sh'
            ]" \
            --timeout-seconds 600 \
            --region ${{ env.AWS_REGION }} \
            --query 'Command.CommandId' \
            --output text)
          
          echo "Command ID: $COMMAND_ID"
          echo "Waiting for deployment to complete..."
          
          # Poll for command completion
          for i in {1..30}; do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "${{ steps.get-ec2-info.outputs.instance_id }}" \
              --region ${{ env.AWS_REGION }} \
              --query 'Status' \
              --output text || echo "Unknown")
            
            echo "Attempt $i/30: Status = $STATUS"
            
            if [ "$STATUS" == "Success" ]; then
              echo "‚úÖ Deployment successful!"
              # Show output
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "${{ steps.get-ec2-info.outputs.instance_id }}" \
                --region ${{ env.AWS_REGION }}
              break
            elif [ "$STATUS" == "Failed" ]; then
              echo "‚ùå Deployment failed!"
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "${{ steps.get-ec2-info.outputs.instance_id }}" \
                --region ${{ env.AWS_REGION }}
              exit 1
            fi
            
            sleep 10
          done

      - name: Clean up S3 bucket
        if: always()
        run: |
          echo "Cleaning up S3 deployment bucket..."
          aws s3 rm s3://${{ steps.create-bucket.outputs.bucket_name }}/deploy.tar.gz || true
          aws s3api delete-bucket --bucket ${{ steps.create-bucket.outputs.bucket_name }} || true

      - name: Health check
        run: |
          sleep 30
          INSTANCE_IP="${{ steps.get-ec2-info.outputs.instance_ip }}"
          curl -f http://$INSTANCE_IP:8000/health || exit 1

      - name: Deployment summary
        run: |
          echo "‚úÖ Deployment completed successfully!"
          echo "üåê API URL: http://${{ steps.get-ec2-info.outputs.instance_ip }}:8000"
          echo "üìö Docs: http://${{ steps.get-ec2-info.outputs.instance_ip }}:8000/docs"
